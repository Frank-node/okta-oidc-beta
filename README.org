# This is a file written in Emacs and authored using org-mode (http://orgmode.org/)
# The "README.md" file is generated from this file by running the
# "M-x org-md-export-to-markdown" command from inside of Emacs.
# 
# The rest of the files are generated from this file by running the
# "M-x org-babel-tangle" command from inside of Emacs.
# 
# The options below control the behavior of org-md-export-to-markdown:
#
# Don't render a Table of Contents 
#+OPTIONS: toc:nil
# Don't render section numbers
#+OPTIONS: num:nil
# Turn of subscript parsing: http://super-user.org/wordpress/2012/02/02/how-to-get-rid-of-subscript-annoyance-in-org-mode/comment-page-1/
#+OPTIONS: ^:{}
* Introduction
  Thank you for participating in Okta's OpenID Connect (OIDC) Beta.

  In this document, we will show you how to get started using OpenID
  Connect with Okta. 

  Specifically demonstrated are the following two use-cases:
  1. Using OpenID Connect to authenticate Okta users to a backend
     web server (If your familiar with SAML, this is roughly
     equivalent to "SP-initiated SAML").
  2. Using OpenID Connect with a JavaScript Single Page Application.

  If you have any questions, comments, or suggestions for this
  document please contact JoÃ«l Franusic <joel.franusic@okta.com>
** FIXME: Explain what BETA means				   :noexport:
* How to run this demo
  This repository comes with code that you can run yourself to see how
  OIDC works. You can run this code locally on your machine, or you
  can deploy the code to Heroku.
** Deploy to Heroku						   :noexport:
*** TODO Add a "Deploy to Heroku" button here!
** Prerequisites
   All examples in this guide assume that you have an Okta org, API
   token, and Okta OAuth Client ID. 

   Running the code samples locally will require the use of Python and
   the [[https://en.wikipedia.org/wiki/Pip_%28package_manager%29][pip]] package manager.

   Here is how to get those things if you do not have them already:
*** Okta org
   If you do not have an Okta org, you can [[https://www.okta.com/developer/signup/][sign up for a free Developer
   Edition Okta org]].
*** Okta API token
   If you do not have an API token, follow our guide for
   [[http://developer.okta.com/docs/api/getting_started/getting_a_token.html][getting a token]].
*** Okta OAuth Client ID
    :PROPERTIES:
      :CUSTOM_ID: oauth-client-id
    :END:

    The easiest way to register an OAuth client is by creating a new
    application integration from the Okta Admin interface:

    1. Log in to your Okta org as an administrator.
    2. After logging in, click on the "Admin" button.
    3. From the "Shortcuts" on the right hand side of the screen,
       click "Add Applications"
    4. Click the "Create New App" button, which is on the left hand
       side of the screen.
    5. *Important:* In the "Platform" section, select "Single Page App (SPA)"
    6. Select "OpenID Connect" as the "Sign on method"
    7. Configure one or more "Redirect URIs" for your application.
    8. Click "Finish"
    9. Using the "People" or "Groups" tabs, assign people to your
       newly created application. 
       *Note:* Users will not be able to authenticate to your
       application if they are not assigned!
    10. Find your "Client ID" in the "Client Credentials" section of
        the "Groups" tab. 

    The Client ID that you just obtained is what you will use to
    configure the demo application in this guide, or to integrate your
    application with Okta.
*** [OLD] Okta OAuth Client ID 					   :noexport:
    At the moment, the only way to register an OAuth client with Okta
    is via Okta's =/oauth2/= API endpoint.

    The recommended method of doing this is via [[http://developer.okta.com/docs/api/getting_started/api_test_client.html][Postman]], using this
    Postman Collection for Okta's [[https://beta.getpostman.com/collections/2bece1641e75a7d4a222][Client Registration API endpoint]].

    Use the "Create OAuth Client" template in Postman, replacing data in the
    sections as appropriate for your situation. The most important
    value to change in the example JSON payload is the array value for the
    =redirect_uris= key. 

    It is important that the =redirect_uris= array contains the URL
    for the site that will be making requests against Okta. If you're
    using the instructions below, this URL will look like
    "=https://abc123de4.ngrok.io=" or
    "=https://example.herokuapp.com=".

    Don't worry if you don't yet know the URL that you'll be using
    here, you can always update the value of =redirect_uris= using an
    HTTP PUT.

    It isn't required, but we suggest that
    you also change the values for the =client_name=, =client_uri=, =logo_uri=, and =jwks_uri= keys.

    Here is an example HTTP request to create an Okta OAuth client via
    the =/oauth2/= API endpoint:
    #+BEGIN_EXAMPLE
      POST /oauth2/v1/clients HTTP/1.1
      Host: example.okta.com
      Accept: application/json
      Content-Type: application/json
      Authorization: SSWS 01A2bcDefGhI34JKlmnOp5qRstUVWXy6ZABCdefgHi

      {
          "client_name": "Example Okta OAuth Client",
          "client_uri": "https://example.com",
          "logo_uri": "https://static.example.com/logo.png",
          "redirect_uris": [
               "https://example.com/oauth/callback1",
               "https://example.com/oauth/callback2"
          ],
          "response_types": [
               "code",
               "token",
               "id_token"
          ],
          "grant_types": [
               "authorization_code",
               "implicit"
          ],
          "token_endpoint_auth_method": "private_key_jwt",
          "jwks_uri": "https://static.example.com/certs/public.jwks"
      }
    #+END_EXAMPLE
*** Python
    While the code samples in this guide are written in Python, you do
    not need Python to use OpenID Connect with Okta.

    To run the code samples in this project you will need a working
    copy of Python 2.7+ and the pip package manager. See this guide on
    "[[http://docs.python-guide.org/en/latest/starting/installation/][Properly Installing Python]]"  for instructions for setting up
    Python on your system.
** Setup
   Once you have all the prerequisites, the next step will be do get
   this example code running. You can either run this code from your
   local machine, or by running the code from Heroku.

** Make a local copy of this repository
   Before you can make use of the code in this guide, you will need a
   local copy of the code to work from. You can either download a copy
   of this repository using the "Download ZIP" button or using the =git
   clone= command.

   Using =git clone= is the suggested method for making a local copy of
   this repository, because getting updates to this repository will be
   as easy as running =git pull origin master=.
** Running on your local machine
   With a local copy of this repository on your machine, the next step
   will be to set up the project.

   You can do this on Mac OS X and Linux by running these commands from the shell:

   #+BEGIN_EXAMPLE
     $ virtualenv venv
     $ source venv/bin/activate
     $ pip install -r requirements.txt
   #+END_EXAMPLE

   If you are using Homebrew on OS X, you /might/ need to follow the
   [[http://cryptography.readthedocs.org/en/latest/installation/#building-cryptography-on-os-x][Homebrew specific installation instructions]] to install the Python =cryptography= library:
   #+BEGIN_EXAMPLE
     $ env CRYPTOGRAPHY_OSX_NO_LINK_FLAGS=1 LDFLAGS="$(brew --prefix openssl)/lib/libssl.a $(brew --prefix openssl)/lib/libcrypto.a" CFLAGS="-I$(brew --prefix openssl)/include" pip install cryptography
   #+END_EXAMPLE

   On OS X or Linux, *replace the example values in the commands below
   with your data* and then run the modified commands in your shell to
   configure the application:
   #+BEGIN_EXAMPLE
     $ export OKTA_API_TOKEN=00A0B12CDefGHijkLmN3OPQRsTu4VWxyzABCdEf56G
     $ export OKTA_BASE_URL=https://example.okta.com
     $ export OKTA_CLIENT_ID=aBcDEfG0HiJkL1mn2oP3
   #+END_EXAMPLE

   Use this command to run the application locally on your system:
   #+BEGIN_EXAMPLE
     $ python app.py
   #+END_EXAMPLE

*** Make the example available via HTTPS using ngrok
    As a last step, you will need to make your local copy of the
    example code available via HTTPS. You need to do this because the
    [[http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthRequest][OpenID Connect specification requires that you do so]]. 

    The easiest way to do this is using the excellent tool "[[https://ngrok.com/][ngrok]]".

    To get started with ngrok, visit the
    [[https://ngrok.com/download]["Download" page for ngrok]], download ngrok, then start it on your
    system.

    Assuming that your example code is listening on
    =http://localhost:5000=, start ngrok with the following command:
    #+BEGIN_EXAMPLE
     $ ngrok http 5000
    #+END_EXAMPLE

    When ngrok starts, you will see a page that give you information
    on the ngrok. Look for the line that starts with *Forwarding* and
    then copy the URL that starts with "https", it will look something
    like this: =https://ab123cd4.ngrok.io= - this is the URL that you
    will use in the following steps.

** Running on Heroku
   Assuming that you've already installed the
   [[https://toolbelt.heroku.com/][Heroku Toolbelt]], here are the commands you'd use to deploy this
   application to Heroku:
   #+BEGIN_EXAMPLE
     $ heroku create
     $ git push heroku master
   #+END_EXAMPLE

   Then, configure the application using these commands below. 
   *Make sure to replace the values below with your data!*
   #+BEGIN_EXAMPLE
     $ heroku config:set OKTA_API_TOKEN=00A0B12CDefGHijkLmN3OPQRsTu4VWxyzABCdEf56G
     $ heroku config:set OKTA_BASE_URL=https://example.okta.com
     $ heroku config:set OKTA_CLIENT_ID=aBcDEfG0HiJkL1mn2oP3
   #+END_EXAMPLE

   Finally:
   #+BEGIN_EXAMPLE
     $ heroku open
   #+END_EXAMPLE
   
** Whitelist URL in Okta
   The last thing that you will need to do is add the URL for your
   example application to the appropriate Okta whitelists. This is
   done in two places: 
   1. The OAuth client configuration in your Okta org
   2. The CORS settings in your Okta org

   If you're using ngrok or Heroku to host your example application,
   then your URL will look like this "=https://abc123de4.ngrok.io=" or
    "=https://example.herokuapp.com=".

*** Update the OAuth Client =redirect_uris= array
    If you didn't do it when you created your [[#oauth-client-id][OAuth Client ID]], you
    will need to go back to that section and follow the instructions
    to add your URL to the =redirect_uris= whitelist.

*** Update CORS configuration on the Okta web page
    You will also need to enable the URL for CORS. See 
    [[http://developer.okta.com/docs/api/getting_started/enabling_cors.html][Okta's guide to Enabling CORS]] for details on how to do this.
** Open the URL for the example application in your browser
   
   If you're using ngrok or Heroku to host your example application,
   then your URL will look like this "=https://abc123de4.ngrok.io=" or
    "=https://example.herokuapp.com=".
* How it works
  The core of using Open ID Connect with your application is the
  =id_token=, which is a JSON Web Token (JWT).

  Below is an example of what a JWT looks like:
  #+BEGIN_EXAMPLE
    eyJhbGciOiJSUzI1NiJ9.eyJ2ZXIiOjEsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5va3RhLmNvbSIsIn
    N1YiI6IjAwdTBhYmNkZWZHSElKS0xNTk9QIiwibG9naW4iOiJ1c2VybmFtZUBleGFtcGxlLmNvbSIsI
    mF1ZCI6IkFiY0RFMGZHSEkxamsyTE0zNG5vIiwiaWF0IjoxNDQ5Njk1NjAwLCJleHAiOjE0NDk2OTky
    MDAsImFtciI6WyJwd2QiXSwiYXV0aF90aW1lIjoxNDQ5Njk1NjAwfQ.btq43W2-SOsc7BA_SyMPEKcu
    2xUYoyLuY948k6tWzZAsy__MndK9pX3WjYYMwkGqfthLjMWXMuYem2-uWcdwfDCDpWoxK4Es3N8dnsQ
    NeS_U0_FfVZfkj_OMGw28RPDLRErNAuyXFj2DegXUh74PEZcDaKSz5-17znEpXgzbT14
  #+END_EXAMPLE
  *Note:* The line breaks have been added for readability.

  A JWT is, essentially, a base64 encoded JSON object. Here is what
  the JWT above looks like after it has been decoded and validated:
  #+BEGIN_SRC javascript
    {
      "ver": 1,
      "iss": "https://example.okta.com",
      "sub": "00u0abcdefGHIJKLMNOP",
      "login": "username@example.com",
      "aud": "AbcDE0fGHI1jk2LM34no",
      "iat": 1449695600,
      "exp": 1449699200,
      "amr": [
        "pwd"
      ],
      "auth_time": 1449695600
    }
  #+END_SRC
* Getting an id_token from Okta
  The easiest way to get an =id_token= from Okta is to use the Okta
  Sign-In Widget. Here is how to configure the Okta Sign-In Widget
  to give you an =id_token=:

  #+NAME: init-okta-sign-in-for-oidc
  #+BEGIN_SRC javascript :exports none
    var oktaSignIn = new OktaSignIn({
        baseUrl: baseUrl,
        clientId: clientId,
        authParams: {
            responseType: 'id_token',
            responseMode: 'okta_post_message',
            scope: ['openid']
        }
    });
  #+END_SRC

  #+NAME: setup-okta-sign-in
  #+BEGIN_SRC javascript :noweb yes
    function setupOktaSignIn(baseUrl, clientId) {
        <<init-okta-sign-in-for-oidc>>
        return oktaSignIn;
    };
  #+END_SRC
  Note: Other valid types for =authParams.scope= are: =openid=,
  =email=, =profile=, =address=, =phone=, and =groups=.
** TODO Add =groups= when appropriate				   :noexport:
** TODO How to add Social Login buttons				   :noexport:
  #+BEGIN_SRC javascript :exports none
    function setupOktaSignIn(baseUrl, clientId) {
	var redirectUri = baseUrl + '/oauth2/v1/widget/callback?targetOrigin=' + window.location.href;
	return new OktaSignIn({
	    baseUrl: baseUrl,
	    clientId: clientId,
	    redirectUri: redirectUri,
	    authScheme: 'OAUTH2',
	    authParams: {
		responseType: 'id_token',
		scope: [ 'openid' ]
	    },
	    idps: [
		{
		  'type': 'FACEBOOK',
		  'id': '0FAKE0FAKE'
		}
	    ]
	});
    };
  #+END_SRC
* Use cases
  The OpenID Connect specification makes provisions for many different
  use cases. For this beta, we are support two use cases:

  1. Server-side web application
     Authenticating against a web application that runs on a server.
  2. Single Page Application
     Authenticating a client-side JavaScript application that runs in
     a web browser.

** Server-side web application 

   This use case demonstrates how to have a server-side web
   application authenticate users via OpenID Connect. If you are
   familiar with SAML, this is the same use case as "SP initiated
   SAML".

   Authenticating Okta users against your server-side web application
   consists of these core steps:
   1. Okta authenticates a user.
   2. Upon a successful authentication, Okta issues the user an OIDC
      =id_token= and direct the users browser to deliver the
      =id_token= to your web application.
   3. Your server-side web application will validate the =id_token=
      and, if the token is valid, will create a session for the user
      so that the user is "logged in" to your web application.

   Step 2 is covered below in the "Getting an OIDC =id_token= from
   Okta" section and Step 3 is covered in the "Validating an OIDC
   =id_token= from Okta" section.

*** Getting an OIDC =id_token= from Okta

    Currently, there are three ways to get an =id_token= from Okta,
    sorted in order if "ease of implementation":
    1. Having users click on a special link that will redirect them
       through Okta.
    2. Authenticating users via the Okta Sign-In Widget.
    3. Authenticating users via [[http://developer.okta.com/docs/api/resources/authn.html][/authn]] and [[http://developer.okta.com/docs/api/resources/oidc.html][/oauth2]] Okta API endpoints.

    Which method you select depends on how customized you want the
    user's login experience to be. 

    If you don't care about a customized login experience, the easiest
    way to get an =id_token= from Okta is to have users click on a
    special link that will redirect them through Okta to your
    application.

    The Okta Sign-In Widget handles all possible user states and is
    moderately customizable. It is a good choice if you don't have
    extremely detailed design requirements.

    Using the Okta API endpoints directly gives you the most
    flexibility in terms of customization at the expense of requiring
    you to support all of the possible flows that your users will go
    through.

    Details on each of these methods are below:

*** Getting an =id_token= via a special Okta link

    If you don't mind your users seeing an Okta branded login page,
    having your users login to your application using the OpenID
    Connect "Code Flow".

    The basics of implementing the Code Flow are below. For more
    information in the Code Flow, we suggest reading the "OpenID Connect Basic Client
    Implementer's Guide", which contains a good [[https://openid.net/specs/openid-connect-basic-1_0.html#CodeFlow][guide to implementing the
    OIDC Code Flow]].

    See our [[http://developer.okta.com/docs/api/resources/oidc.html#request-parameters][OIDC documentation for details on the request parameters]]
    for more details on how Okta uses the OIDC request parameters.

    Below is an example of what this link might look like:

    #+BEGIN_SRC python :noweb yes :results code :exports results
      import urllib
      <<create_authorize_url>>

      redirect_url = create_authorize_url(
          base_url='https://example.okta.com',
          client_id='a0bcdEfGhIJkLmNOPQr1',
          scope='openid',
          response_type='id_token',
          response_mode='form_post',
          redirect_uri="https://example.com/sse/oidc",
      )

      return redirect_url
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC python
    https://example.okta.com/oauth2/v1/authorize?redirect_uri=https%3A%2F%2Fexample.com%2Fsse%2Foidc&response_type=id_token&client_id=a0bcdEfGhIJkLmNOPQr1&scope=openid&response_mode=form_post
    #+END_SRC


*** Getting an =id_token= via the Okta Sign-In Widget

    The easiest way customize the login experience that your users
    see is to use the [[http://developer.okta.com/docs/guides/okta_sign-in_widget.html][Okta Sign-In Widget]].

    To use the Okta Sign-In Widget with your application, follow the
    [[http://developer.okta.com/docs/guides/okta_sign-in_widget.html][guide for setting up the Okta Sign-In Widget]] but make the
    following two changes to your configuration of the Okta Sign-In Widget:


    1. Configure the Sign-In Widget to request an OIDC =id_token=:
       #+BEGIN_SRC javascript :noweb yes :padline no
	 <<init-okta-sign-in-for-oidc>>
       #+END_SRC
    2. Add a "SUCCESS" handler to the widget which will extract the
       =id_token= and pass it on to your application backend service.

       Here is how this is done in the example application in this project:
       #+BEGIN_SRC javascript :noweb yes
	 <<configure-okta-sign-in-success-handler>>
       #+END_SRC

*** Getting an =id_token= via Okta API endpoints
    Lastly, if you need to make customizations to the login
    experience beyond what the Sign-In Widget allows, you can do that
    by making API requests directly to the Okta API.

    At a high level, what you will need to do is write some code on
    your application backend that will do the following:
    - Accepts a *username* and *password*
    - Uses the *username* and *password* to make a request to Okta's
      =/authn= API endpoint and extracts the =sessionToken= from the
      results of a successful request.
    - Redirects the user to an Okta's =/oauth2/v1/authorize= API
      endpoint using the =sessionToken= in the request parameters.

    Here is how this is done in the example application:

    #+BEGIN_SRC python :noweb yes
    <<route_login>>
    #+END_SRC

    And here is the =create_authorize_url= function that is used to
    construct the request to =/oauth2/v1/authorize= with the proper
    request parameters:

    #+BEGIN_SRC python :noweb yes
    <<create_authorize_url>>
    #+END_SRC
    
*** Validating an OIDC =id_token= from Okta
    An OIDC =id_token= is a JWT and validating a JWT is easy. Below is a
    demonstration of how to validate a JWT in Python using the [[https://github.com/jpadilla/pyjwt#pyjwt][pyjwt]]
    Python library.
    
    (See [[http://jwt.io/#libraries-io][JWT.io]] for a list of JWT libraries in your favorite language.)

    The [[https://github.com/jpadilla/pyjwt#pyjwt][pyjwt]] library handles a lot of ancillary JWT validation by
    default. In particular, it validates the =audience= attribute,
    which means that it will return an error unless the value
    =audience= attribute matches what we pass into this method.

    Here is how we parse a JWT in this sample application:

    #+NAME: parse-jwt
    #+BEGIN_SRC python :noweb yes :padline no
      def parse_jwt(id_token):
          public_key = fetch_jwt_public_key_for(id_token)
          rv = jwt.decode(
              id_token,
              public_key,
              <<force_rs256>>
              <<issuer_base_url>>
              <<audience_client_id>>
          return rv
    #+END_SRC

    Here is base test that we use for the =parse_jwt= function:

    #+NAME: test_parse_jwt_valid
    #+BEGIN_SRC python :padline no
      @responses.activate
      def test_parse_jwt_valid(self):
          id_token = self.create_jwt(claims={})
          rv = flask_app.parse_jwt(id_token)
          self.assertEquals('00u0abcdefGHIJKLMNOP', rv['sub'])
    #+END_SRC

    Here are some details on the parameters that we are explicitly
    setting in =parse_jwt=:

    1. Force the JWT signing algorithm to =RS256=
       
       This line forces the JWT signing algorithm to =RS256=:
       #+NAME: force_rs256
       #+BEGIN_SRC python
         algorithms='RS256',
       #+END_SRC

       We do this because it is a best practice for handling JWTs and
       is done to avoid [[https://www.chosenplaintext.ca/2015/03/31/jwt-algorithm-confusion.html][critical vulnerabilities in JSON Web Token libraries]].

    2. The OIDC Issuer

       This line sets the =issuer= to the value of the Okta Base URL,
       which is what Okta uses as the =issuer=:
       #+NAME: issuer_base_url
       #+BEGIN_SRC python
         issuer=okta['base_url'],
       #+END_SRC

       And this is how we test that the JWT decoder is properly
       validating the =issuer=:

       #+NAME: test_parse_jwt_invalid_issuer
       #+BEGIN_SRC python :padline no
         @responses.activate
         @raises(jwt.InvalidIssuerError)
         def test_parse_jwt_invalid_issuer(self):
             id_token = self.create_jwt(claims={'iss': 'https://invalid.okta.com'})
             flask_app.parse_jwt(id_token)

         @responses.activate
         @raises(ValueError)
         def test_parse_jwt_invalid_issuer_domain(self):
             id_token = self.create_jwt(
                 claims={'iss': 'https://invalid.example.com'},
                 kid='EXAMPLEKID')
             flask_app.parse_jwt(id_token)
       #+END_SRC

    3. The OIDC Audience

       This line sets the =audience= to the value of the Okta OAuth
       Client ID, which is what Okta uses as the =audience=:
       #+NAME: audience_client_id
       #+BEGIN_SRC python
         audience=okta['client_id'])
       #+END_SRC

       And this is how we test that the JWT decoder is properly
       validating the =audience=:

       #+NAME: test_parse_jwt_invalid_audience
       #+BEGIN_SRC python :padline no
         @responses.activate
         @raises(jwt.InvalidAudienceError)
         def test_parse_jwt_invalid_audience(self):
             id_token = self.create_jwt(claims={'aud': 'INVALID'})
             flask_app.parse_jwt(id_token)
       #+END_SRC

       Okta uses the OAuth Client ID as the audience in the
       =id_token= JWTs that it issues. We pass this value to =pyjwt= so
       that our JWTs are properly validated.
    

    Where does the =public_key= come from? It is fetched from the
    [[https://example.okta.com/oauth2/v1/keys][Okta JSON Web Key endpoint]] - which can be discovered via the
    [[https://example.okta.com/.well-known/openid-configuration][.well-known/openid-configuration]] URL.

    Below is a demonstration of how to fetch the public key for
    =example.okta.com= using the command line (on OS X).

    On the first line, we pull down the JSON from
    =.well-known/openid-configuration= and pull out the =jwks_uri=
    element using =grep= and a regular expression (the "[[https://github.com/stedolan/jq][jq]]" command line
    tool is better suited for this, but not installed by
    default). Once we have the =jwks_uri=, we use that to fetch the
    key from Okta, pull out the =x5c= key using grep, base64 decode
    the =x5c= key, then pipe that to =openssl= to extract the public key.

    #+BEGIN_SRC sh :results code :exports both
      JWKS_URI=`curl -s https://example.okta.com/.well-known/openid-configuration | egrep -o 'jwks_uri":"[^"]*' | cut -d '"' -f 3`;
      curl -s $JWKS_URI | egrep -o '"x5c":\["[^]]*' | cut -d '"' -f 4 | tr -d '\' | base64 -D | openssl x509 -inform DER -pubkey -noout
    #+END_SRC

    #+RESULTS:
    #+BEGIN_SRC sh
    -----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjKb91FLaoZe9/5NEMZrO
    1eDn4hdrhtjrvsy+qO1QIbbdhRXJIJoE+qpHmgmq1gK28OZCV51xUAwk8ugw5p7/
    m2wIarykHtXuBmhcFPkWez6N/yX30qvdOPPKUGqd05AoGcrzAW6fV07CRROU+5g1
    RnTdNasLEMYaq0xPlmCMDjb3usyiafGyyrwg4+tndOTry4uMtF7LeTVLZo9Tnn2x
    dJiytWWh+Rq5/KAn1mJ2GgwG8tp8o7SRf65c0LYQenN1d6vXX/Iimq/mg//B5CHP
    zIaUrZfoL+2sbRIyQ5AePlDyn8Neg6sIsV9nTkPAcYvvQsS+/8xnfNq6np0zKbua
    dQIDAQAB
    -----END PUBLIC KEY-----
    #+END_SRC

    #+BEGIN_SRC sh :exports none
      JWKS_URI=`curl -s https://example.okta.com/.well-known/openid-configuration | jq -r '.jwks_uri'`;
      curl $JWKS_URI | jq -r '.keys[0].x5c[0]' | base64 -D | openssl x509 -inform DER -pubkey -noout
    #+END_SRC

*** Fetching public keys for OIDC in Python
    Since this example uses Python, below is an example of how to
    autodiscover the JWKS URL for an Okta OIDC endpoint by appending
    the =/.well-known/openid-configuration=  string to the end of the
    URL that is in the =iss= OIDC claim.

    Below is some Python code that demonstrates how to automatically
    discover the JWKS URL and parse the public keys from that URL in.

    This is what it does:
    1. Checks the =id_token= header for a =kid= ("Key ID"). Fail validation
       if the =id_token= doesn't have a =kid=.
    2. Use the =kid= to see if we have previously cached the public key for that =kid=.
       If we already have a public key, then use that to validate the
       =id_token=.

    Here an example in Python that checks to see if the =id_token= has
    a =kid=, and if so, checks if we've seen the public key for that
    =kid= before:
    #+NAME: lookup_public_key_by_key_id
    #+BEGIN_SRC python :padline no
      dirty_header = jws.get_unverified_header(id_token)
      cleaned_key_id = None
      if 'kid' in dirty_header:
          dirty_key_id = dirty_header['kid']
          cleaned_key_id = re.sub(not_alpha_numeric, '', dirty_key_id)
      else:
          raise ValueError('The id_token header must contain a "kid"')
      if cleaned_key_id in public_keys:
          return public_keys[cleaned_key_id]
    #+END_SRC
    
    #+BEGIN_QUOTE
    *Note*: In this example, we are using a Python Dictionary called
    =public_keys= as our hash. In production you should use whatever
    existing caching infrastructure you have in place.
    #+END_QUOTE

    If we haven't yet seen a public key matching the =kid=, then we
    fetch the public key as follows:

    1. Take the URL from the =iss= claim in the =id_token=.
    2. Validate that the domain name in the =iss= claim is a valid
       Okta domain name.
    3. If the domain name is valid, append
       =/.well-known/openid-configuration= to the end of the URL in
       the =iss= claim.
    4. Fetch the URL above and take the =jwks_uri= key from the results.
    6. Fetch the =jwks_uri= and, for each key in the result, it do
       the following:
       - Take the first element in the =x5c= value.
       - Base64 decode the DER encoded x509 certificate.
       - Parse the DER encoded x509 certificate using the Python
         =cryptography= library.
       - Store the public key in a hash, using the =kid= as the
         value.

    Here an example in Python that does what is described above:

    #+NAME: fetch_public_key_via_jwks
    #+BEGIN_SRC python :padline no
      dirty_id_token = jwt.decode(id_token, verify=False)
      dirty_url = urlparse.urlparse(dirty_id_token['iss'])
      if domain_name_for(dirty_url) not in allowed_domains:
          raise ValueError('The domain in the issuer claim is not allowed')
      cleaned_issuer = dirty_url.geturl()
      oidc_discovery_url = "{}/.well-known/openid-configuration".format(
          cleaned_issuer)
      r = requests.get(oidc_discovery_url)
      openid_configuration = r.json()
      jwks_uri = openid_configuration['jwks_uri']
      r = requests.get(jwks_uri)
      jwks = r.json()
      for key in jwks['keys']:
          jwk_id = key['kid']
          first_element = 0
          jwk_x5c = key['x5c'][first_element]
          der_data = base64.b64decode(str(jwk_x5c))
          cert = x509.load_der_x509_certificate(der_data, default_backend())
          public_keys[jwk_id] = cert.public_key()
    #+END_SRC


    When extracting the =iss= claim from the =id_token= we strongly
    urge you to treat that value as untrusted and validate the
    contents before using it. 

    In the example above, we parse the URL in the =iss= claim and
    check that the domain matches "okta.com" or
    "oktapreview.com". This is done using the =domain_name_for=
    function below:

    #+NAME: domain_name_for
    #+BEGIN_SRC python :padline no
      def domain_name_for(url):
          second_to_last_element = -2
          domain_parts = url.netloc.split('.')
          (sld, tld) = domain_parts[second_to_last_element:]
          return sld + '.' + tld
    #+END_SRC

    For more details on the =x5c= format, see the [[https://tools.ietf.org/html/draft-ietf-jose-json-web-key-31#section-4.7]["x5c" section in the
    JSON Web Key specification]], which is quoted below:
    
    #+BEGIN_QUOTE
    The "x5c" (X.509 Certificate Chain) member contains a chain of one
    or more PKIX certificates [RFC5280].  The certificate chain is
    represented as a JSON array of certificate value strings.  Each
    string in the array is a base64 encoded ([RFC4648] Section 4 --
    not base64url encoded) DER [ITU.X690.1994] PKIX certificate value.
    The PKIX certificate containing the key value MUST be the first
    certificate.  This MAY be followed by additional certificates,
    with each subsequent certificate being the one used to certify the
    previous one.  The key in the first certificate MUST match the
    public key represented by other members of the JWK.  Use of this
    member is OPTIONAL.

    As with the "x5u" member, members other than those representing
    the public key may also be populated when an "x5c" member is
    present.  If other members are present, the contents of those
    members MUST be semantically consistent with the related fields in
    the first certificate.  See the last paragraph of Section 4.6 for
    additional guidance on this.
    #+END_QUOTE

    Finally, here is what the function looks like when it's all put
    together, with additional error handling code:

    #+NAME: fetch-jwt-public-key-for
    #+BEGIN_SRC python :noweb yes :padline no
      def fetch_jwt_public_key_for(id_token=None):
          if id_token is None:
              raise NameError('id_token is required')

          <<lookup_public_key_by_key_id>>

          <<fetch_public_key_via_jwks>>

          if cleaned_key_id in public_keys:
              return public_keys[cleaned_key_id]
          else:
              raise RuntimeError("Unable to fetch public key from jwks_uri")
    #+END_SRC

    #+NAME: test_fetch_public_key_for_when_empty
    #+BEGIN_SRC python :exports none
      @raises(NameError)
      def test_fetch_public_key_for_when_empty(self):
          flask_app.fetch_jwt_public_key_for()
    #+END_SRC

    #+NAME: test_parse_jwt_invalid_kid
    #+BEGIN_SRC python :padline no :exports none
      @responses.activate
      @raises(RuntimeError)
      def test_parse_jwt_invalid_kid(self):
          id_token = self.create_jwt(claims={}, kid='INVALIDKID')
          flask_app.parse_jwt(id_token)
    #+END_SRC

    #+NAME: test_parse_jwt_no_kid
    #+BEGIN_SRC python :padline no :exports none
      @responses.activate
      @raises(ValueError)
      def test_parse_jwt_no_kid(self):
          id_token = self.create_jwt(claims={}, kid=None)
          flask_app.parse_jwt(id_token)
    #+END_SRC

** Single Page App

   This use case demonstrates how to have a Single Page application
   authenticate users via OpenID Connect.

   The code in this example is contained in two static files:
   =templates/spa.html= for the HTML and =static/single-page.js= for
   the application JavaScript.

   The JavaScript used to demonstrate this use case is covered below:
  
   We start with the code used to initialize the Okta Sign-In Widget
   in the =spa.html= file, Note that the ={{okta.base_url}}= and
   ={{okta.client_id}}= strings are place holders for the [[http://jinja.pocoo.org/][Jinja2]]
   templating engine that Flask uses to render the =spa.html=
   template.
    #+NAME: single-page-okta-config
    #+BEGIN_SRC javascript :padline no
      var oktaSignIn = setupOktaSignIn('{{okta.base_url}}', '{{okta.client_id}}');
  
      $(document).ready(function () {
          // defined in 'single-page.js'
          renderOktaWidget();
      });
    #+END_SRC

   The rest of the code used in this demonstration is contained in the
   =single-page.js= file. 

   This demonstration application is a very simplistic and
   /unrealistic/ implementation of a Single Page Application. Instead
   of using a framework [[https://angularjs.org/][Angular]], [[http://emberjs.com/][Ember]], or [[https://facebook.github.io/react/][React]], this examples uses
   [[https://jquery.com/][jQuery]] to update the page.

   (Using jQuery is easier to understand, but you /should not/ use jQuery
   to write a production quality Single Page Application.)

   The =single-page.js= file defines three functions:
   - =renderOktaWidget()=
     This handles rendering of the Okta widget.
   - =renderLogin()=
     What gets called when a user logs in with a =status= of
     "=SUCCESS=".
   - =renderLogout()=
     What gets called when a user clicks a "Logout" button or link.

   #+BEGIN_SRC javascript :tangle static/single-page.js :noweb yes :exports none
     <<single-page-app-render-sign-in>>

     <<single-page-app-render-login>>

     <<single-page-app-render-logout>>
   #+END_SRC

   We will cover each function below.

*** =renderOktaWidget()=

    Below is the =renderOktaWidget()= function which calls the
    =renderEl= ("render El"ement) method of
    =oktaSignIn=. =renderEl= takes three arguments:
    1. =widget-location-object=
       A JavaScript object which contains the =id= of the HTML element
       that should be turned into the Okta Sign-In Widget.
    2. =widget-success-function= 
       A function that is called on successful authentications.
    3. =widget-error-function=
       A function that is called when error conditions are encountered.

    Here is what the =renderEl= function looks like at a high level:
    #+NAME: single-page-app-render-sign-in
    #+BEGIN_SRC javascript  :noweb yes
      function renderOktaWidget() {
          oktaSignIn.renderEl(
              <<widget-location-object>>,
              <<widget-success-function>>,
              <<widget-failure-function>>
          );
      }
    #+END_SRC

    Let's cover each of those sections in detail:

    Below we pass =renderEl= "=#okta-sign-in-widget=", which is the
    HTML =id= for the =<div>= tag that we want to contain the Okta
    Sign-In Widget.

    #+NAME: widget-location-object
    #+BEGIN_SRC javascript
      { el: '#okta-sign-in-widget' }
    #+END_SRC


    Next, we pass =renderEl= a function that makes an [[https://en.wikipedia.org/wiki/Ajax_(programming)][Ajax]] request to
    =/users/me=. This call passes the =id_token= in the
    =Authorization= header to validate the request. If everything
    works as expected, then we call the =renderLogin()= function with
    the user's Okta ID as a parameter.
    
    #+NAME: widget-success-function
    #+BEGIN_SRC javascript
      function (res) {
          if (res.status === 'SUCCESS') {
              console.log(res);
              var id_token = res.id_token || res.idToken;
              $.ajax({
                  type: "GET",
                  dataType: 'json',
                  url: "/users/me",
                  beforeSend: function(xhr) {
                      xhr.setRequestHeader("Authorization", "Bearer " + id_token);
                  },
                  success: function(data){
                      renderLogin(data.user_id);
                  }
              });
          }
      }
    #+END_SRC

    Lastly, we pass =renderEl= an error handling function. In this
    example, we pass in a very simple error handling function that
    just calls =console.log()= with the error message. This is only
    useful while developing your custom logic for the Okta Sign-In
    Widget and you will want to do something different in a production
    deployment.
    #+NAME: widget-failure-function
    #+BEGIN_SRC javascript
      function (err) { console.log('Unexpected error authenticating user: %o', err); }
    #+END_SRC
*** =renderLogin()=

    Below is an overview of what the =renderLogin()= function
    does:
    #+NAME: single-page-app-render-login
    #+BEGIN_SRC javascript :noweb yes
      function renderLogin(user_id) {
          <<display-log-out-message>>
          <<display-logged-in-message>>
          <<display-user-id>>
      }
    #+END_SRC

    Here is what each of the sections above do:

    First, we add a "Log out" item
    to the navbar, then register a =click()= event for when the user
    clicks on "Log out":
    #+NAME: display-log-out-message
    #+BEGIN_SRC javascript
      $('#navbar > ul').empty().append('<li><a id="logout" href="/logout">Log out</a></li>');
      $('#logout').click(function(event) {
          event.preventDefault();
          renderLogout();
      });
    #+END_SRC

    Next, we hide the "logged out" message and display the "logged in" message:
    #+NAME: display-logged-in-message
    #+BEGIN_SRC javascript
      $('#logged-out-message').hide();
      $('#logged-in-message').show();
          
    #+END_SRC

    Lastly, in the =<<display-user-id>>= section, we hide the Okta Sign-In
    Widget append the user's Okta ID into page, then show the part of
    the page with the user's Okta ID:

    #+NAME: display-user-id
    #+BEGIN_SRC javascript
      $('#okta-sign-in-widget').hide();
      $('#okta-user-id').empty().append(user_id);
      $('#logged-in-user-id').show();
    #+END_SRC

    *Note:* The =#okta-sign-in-widget= element can only be
    instantiated once per page, so for a Single Page Application, it
    is critical that you hide the element instead of removing it.

    Convert your code to show and hide the =#okta-sign-in-widget=
    element if your browser's JavaScript console shows an error that says:
    "Backbone.history has already been started" 

*** =renderLogout()=

    The =renderLogout()= function is essentially the opposite of the
    =renderLogin()=, it clears out the navigation bar with =empty=,
    hides the "logged in" message and shows the "logged out" message,
    hides the users Okta ID and shows the Okta Sign-In Widget. (This code
    also clears out the password field in the sign-in widget).

    #+NAME: single-page-app-render-logout
    #+BEGIN_SRC javascript 
      function renderLogout() {
          $('#navbar > ul').empty();
          $('#logged-in-message').hide();
          $('#logged-out-message').show();
          $('#logged-in-user-id').hide();
          $('#okta-sign-in .okta-form-input-field input[type="password"]').val('');
          $('#okta-sign-in-widget').show();
      }
    #+END_SRC
* Source Files 							   :noexport:
** Routes
*** /
    #+NAME: route_main_page
    #+BEGIN_SRC python
      @app.route("/")
      def main_page():
          if len(required.keys()) > 0:
              return render_template(
                  'error.html',
                  required=required,
                  okta=okta)
          redirect_uri = url_for(
              'sso_oidc',
              _external=True,
              _scheme='https')
          login_with_okta_branding = create_authorize_url(
              base_url=okta['base_url'],
              client_id=okta['client_id'],
              scope='openid',
              response_type='id_token',
              response_mode='form_post',
              redirect_uri=redirect_uri)
          target_origin = url_for('main_page', _external=True, _scheme='https')
          return render_template(
              'main_page.html',
              target_origin=target_origin,
              login_with_okta_branding=login_with_okta_branding,
              okta=okta)
    #+END_SRC

    #+NAME: test_has_default_route
    #+BEGIN_SRC python
      def test_has_default_route(self):
          path = "/"
          rv = self.app.get(path)
          self.assertEquals("200 OK", rv.status)
          self.assertIn("<html", rv.data)
    #+END_SRC
*** /secret
    #+NAME: route_secret
    #+BEGIN_SRC python
      @app.route("/secret")
      @login_required
      def logged_in():
          opts = {'user': current_user}
          return render_template(
              'secret.html',
              opts=opts,
              okta=okta)
    #+END_SRC

    #+BEGIN_SRC html :tangle templates/secret.html :noweb yes :exports none
      {% extends "base.html" %}
      {% block body %}
	  <div class="container">
	    <h1>You are logged in!</h1>
	    <div class="row">
	      <div class="col-md-6">
		<!-- Source: http://openclipart.org/detail/176289/top-secret-by-joshbressers-176289 -->
		<img src="/static/top-secret.png" alt="TOP SECRET" />
	      </div>
	      <div class="col-md-6">
		<p>Logged in as User ID: {{ opts.user.user_id }}</p>
	      </div>
	    </div>
	  </div>
      {% endblock %}
    #+END_SRC
*** /spa
    #+NAME: route_spa
    #+BEGIN_SRC python
      @app.route("/spa")
      def spa():
          return render_template(
              'spa.html',
              okta=okta)
    #+END_SRC

    #+NAME: spa.html
    #+BEGIN_SRC html :tangle templates/spa.html :noweb yes :exports none
      {% extends "base.html" %}
      {% block body %}
	    <div class="row">
	      <div class="col-md-6" id="content-left">
		<div id="logged-out-message">
		  <p>
		    This is a demonstration of how to use Okta to handle authentication for a "single page application".
		  </p>
		  <!-- Source: http://openclipart.org/detail/34273/tango-system-lock-screen-by-warszawianka -->
		  <img src="/static/locked-screen.png" alt="Locked computer screen"/>
	       </div>
	       <div id="logged-in-message" style="display: none;">
		 <h1>You are logged in!</h1>
		  <img src="/static/top-secret.png" alt="TOP SECRET" />
	       </div>
	      </div>
	      <div class="col-md-6" id="content-right">
		<div id="okta-sign-in-widget"></div>
		<div id="logged-in-user-id" style="display: none;">
		 <p>Logged in as User ID: <span id="okta-user-id"></span></p>
	       </div>
	      </div>
	    </div>
      {% endblock %}
      {% block javascript %}
	  <script src="/static/single-page.js">
	  </script>
	  <script type="text/javascript">
	    <<setup-okta-sign-in>>

	    <<single-page-okta-config>>
	  </script>
      {% endblock %}
    #+END_SRC
*** /login
    #+NAME: route_login
    #+BEGIN_SRC python
      @app.route("/login", methods=['POST'])
      def login_with_password():
          payload = {
              'username': request.form['username'],
              'password': request.form['password'],
              }

          authn_url = "{}/api/v1/authn".format(okta['base_url'])
          r = requests.post(authn_url, headers=headers, data=json.dumps(payload))
          result = r.json()

          if 'errorCode' in result:
              flash(result['errorSummary'])
              return redirect(url_for('main_page', _external=True, _scheme='https'))

          redirect_uri = url_for(
              'sso_oidc',
              _external=True,
              _scheme='https')
          redirect_url = create_authorize_url(
              base_url=okta['base_url'],
              sessionToken=result['sessionToken'],
              client_id=okta['client_id'],
              scope='openid',
              response_type='id_token',
              response_mode='form_post',
              redirect_uri=redirect_uri,
              )
          return redirect(redirect_url)
    #+END_SRC

    #+NAME: test_login_with_password
    #+BEGIN_SRC python
      @responses.activate
      def test_login_with_password(self):
          sessionToken = 'FAKE_SESSION_TOKEN'
          responses.add(
              responses.POST,
              'https://example.okta.com/api/v1/authn',
              json.dumps({'sessionToken': sessionToken}),
              status=200)
          data = {
              'username': 'username',
              'password': 'password',
              }
          rv = self.app.post('/login', data=data)
          self.assertEquals("302 FOUND", rv.status)
          self.assertIn('LOCATION', rv.headers)
          self.assertIn(sessionToken, rv.headers['Location'])
    #+END_SRC
*** /logout
    #+NAME: route_logout
    #+BEGIN_SRC python
      @app.route("/logout")
      def logout():
          logout_user()
          return redirect(url_for('main_page', _external=True, _scheme='https'))
    #+END_SRC
*** /sso/oidc
    #+NAME: route_sso_oidc
    #+BEGIN_SRC python
      @app.route("/sso/oidc", methods=['GET', 'POST'])
      def sso_oidc():
          if 'error' in request.form:
              flash(request.form['error_description'])
              return redirect(url_for('main_page', _external=True, _scheme='https'))
          id_token = request.form['id_token']
          decoded = parse_jwt(id_token)
          user_id = decoded['sub']
          user = UserSession(user_id)
          login_user(user)
          return redirect(url_for('logged_in', _external=True, _scheme='https'))
    #+END_SRC

    #+NAME: test_sso_via_id_token
    #+BEGIN_SRC python
      @responses.activate
      def test_sso_via_id_token(self):
          id_token = self.create_jwt()
          print id_token
          rv = self.app.post('/sso/oidc', data={'id_token': id_token})
          self.assertIn("Set-Cookie", rv.headers)
          self.assertIn("session=", rv.headers['Set-Cookie'])
          self.assertEquals("302 FOUND", rv.status)

      @responses.activate
      def test_sso_via_id_token_invalid(self):
          id_token = self.create_jwt(claims={'aud': 'invalid'})
          print id_token
          rv = self.app.post('/sso/oidc', data={'id_token': id_token})
          self.assertEquals("500 INTERNAL SERVER ERROR", rv.status)
    #+END_SRC
*** /users/me
    #+NAME: route_users_me
    #+BEGIN_SRC python
      # FIXME: Use decoded['sub'] to fetch the user profile from Okta,
      # returning that in the result
      @app.route("/users/me")
      def users_me():
          authorization = request.headers.get('Authorization')
          token = authorization.replace('Bearer ', '')
          decoded = parse_jwt(token)
          rv = {'user_id': decoded['sub']}
          return flask.jsonify(**rv)
    #+END_SRC
** app.py
*** Imports
  #+NAME: imports
  #+BEGIN_SRC python
    import base64
    import json
    import os
    import re
    import urllib
    import urlparse

    from cryptography import x509
    from cryptography.hazmat.backends import default_backend
    from flask import Flask
    from flask import flash
    from flask import redirect
    from flask import render_template
    from flask import request
    from flask import url_for
    from flask.ext.login import LoginManager
    from flask.ext.login import current_user
    from flask.ext.login import login_required
    from flask.ext.login import login_user
    from flask.ext.login import logout_user
    from jwt.api_jws import PyJWS
    import flask
    import jwt
    import requests
  #+END_SRC
*** Setup Flask-Login
    https://flask-login.readthedocs.org/en/latest/

  #+NAME: setup-flask-login-manager
  #+BEGIN_SRC python
    login_manager = LoginManager()
    login_manager.setup_app(app)


    class UserSession:
        def __init__(self, user_id):
            self.authenticated = True
            self.user_id = user_id

        def is_active(self):
            # In this example, "active" and "authenticated" are the same thing
            return self.authenticated

        def is_authenticated(self):
            # "Has the user authenticated?"
            # See also: http://stackoverflow.com/a/19533025
            return self.authenticated

        def is_anonymous(self):
            return not self.authenticated

        def get_id(self):
            return self.user_id


    # Note that this loads users based on user_id
    # which is stored in the browser cookie, I think
    @login_manager.user_loader
    def load_user(user_id):
        # print "Loading user: " + user_id
        return UserSession(user_id)
  #+END_SRC
*** Create Authorize URL
   #+NAME: create_authorize_url
   #+BEGIN_SRC python :export none
     def create_authorize_url(**kwargs):
         base_url = kwargs['base_url']
         del(kwargs['base_url'])
         redirect_url = "{}/oauth2/v1/authorize?{}".format(
             base_url,
             urllib.urlencode(kwargs),
         )
         return redirect_url
   #+END_SRC
*** Flask App
  #+NAME: flask-app
  #+BEGIN_SRC python :tangle app.py :noweb yes :exports none :padline no
    <<imports>>


    jws = PyJWS()

    not_alpha_numeric = re.compile('[^a-zA-Z0-9]+')

    required = {
        'base_url': {
            'description': 'the base URL for your Okta org',
            'example': 'https://example.okta.com'
        },
        'api_token': {
            'description': 'the API token for your Okta org',
            'example': '01A2bCd3efGh-ij-4K-Lmn5OPqrSTuvwXYZaBCD6EF'
        },
        'client_id': {
            'description': 'an OAuth Client ID for your Okta org',
            'example': 'a0bcdEfGhIJkLmNOPQr1'
        }
    }

    okta = {}
    for key in required.keys():
        env_key = "OKTA_" + key.upper()
        okta[key] = os.environ.get(env_key)
        if okta[key]:
            del(required[key])

    headers = {
        # "Authorization" is only needed for social transaction calls
        'Authorization': 'SSWS {}'.format(okta['api_token']),
        'Content-Type': 'application/json',
        'Accept': 'application/json',
    }

    app = Flask(__name__)

    public_keys = {}
    allowed_domains = ['okta.com', 'oktapreview.com']
    # The 'app.secret_key' variable is used by flask-login
    # to hash the cookies that it gives to logged in users.
    # Since the Okta API token must be kept secret, we will reuse it here.
    # You should set this to your own secret value in a production environment!
    app.secret_key = okta['api_token']

    <<setup-flask-login-manager>>


    <<domain_name_for>>


    <<fetch-jwt-public-key-for>>


    <<route_spa>>


    <<route_secret>>


    <<parse-jwt>>


    <<create_authorize_url>>


    <<route_login>>


    <<route_sso_oidc>>


    <<route_logout>>


    <<route_users_me>>


    <<route_main_page>>


    if __name__ == "__main__":
        # Bind to PORT if defined, otherwise default to 5000.
        port = int(os.environ.get('PORT', 5000))
        if port == 5000:
            app.debug = True
        app.run("0.0.0.0", port=port)
  #+END_SRC
*** FIXME The public key above (=public_key=) should be fetched via the issuer
*** FIXME Change =public_key= to =public_keys= and store using okta org FQDN as the "key"
** tests/test_flask_app.py
   In order to simulate connecting to a JWKs endpoint, we need a
   certificate to use for use in our unit tests. Below is how to
   generate a private key and certificate using OpenSSL. Note that we
   use =/dev/stdout= to capture the output from the command into =org-babel=.

   #+BEGIN_SRC sh :results html
   openssl req -new -newkey rsa:1024 -days 365 -nodes -x509 -subj "/CN=example.com" -keyout /dev/stdout -out /dev/stdout
   #+END_SRC

   #+RESULTS:
   #+NAME: private_key_and_certificate
   #+BEGIN_HTML
   -----BEGIN RSA PRIVATE KEY-----
   MIICXQIBAAKBgQDYrIBJjY822hL90KbvGz/FfbrUbDfCcScc1IzUn95O1I+AXwBX
   yaSh0HJhXEztBvKkfD9+Kq7Blx8EmRfGo6ziT+fZ0mE0WhZv87nFwvedApsCwTEt
   /r3VNNsRmwGGSXxTlbYj1OB3QdGeyl9Gk127akSRBBet7Y2XCezOu809cQIDAQAB
   AoGBALU3MORTfOAHa7LUe4mnZKKsEUHwcIIzWN8H9fEu9CNCK/LVgdfqUcL0L3W2
   WLA1C2L+d6vxzs8isVKLKBN+eOwUnhbMbMtD8h1SbTUV/JFrZsHycNcff4ythjLW
   dMo91+t7EcMKDVmej384Saj8D0z2i1QItvBK/msmSQqdYMXxAkEA72IanU3e5EI1
   rkII0/eVLliK6IM+uhaCgAz7Pt7bxntO2NZ8rscn93v6X7SS2Q/QQKyfsT+AbCXk
   bMCQE/AsFwJBAOe22JWgT1kIlmPVOaid/XErVV9YYdy7SxkAhvQYzHagWfhQaGpX
   sMrX1D5i4eIO9JHRu5zPupCGXRWT43UWr7cCQAi61Smja1t7pqWCNvwz7TbRd89e
   6eyzYXL2BjuWuQEWAhwaRlXBYY2+8bSHy0srLncNVI2MOUy4XQoyQ47WlWUCQGZM
   vZZhrmZ6ehsdWlVtWyWJoil0FdCkB+XD69D82dhNtysAJPk+Odl0LEpW0a9CNwvh
   8tiqhY2lJJeQMU3SdEUCQQCxJ5bXPM5iVDBzV50l3DfDN71srr9KGdCahCuxQpRt
   3ZRkZkz9izeRgRM5GRbOM7xpMWKLXFF0E7Y7jF3aa6xD
   -----END RSA PRIVATE KEY-----
   -----BEGIN CERTIFICATE-----
   MIICITCCAYqgAwIBAgIJAPvk/teL+BzRMA0GCSqGSIb3DQEBBQUAMBYxFDASBgNV
   BAMTC2V4YW1wbGUuY29tMB4XDTE2MDIyMzAwNTg1M1oXDTE3MDIyMjAwNTg1M1ow
   FjEUMBIGA1UEAxMLZXhhbXBsZS5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ
   AoGBANisgEmNjzbaEv3Qpu8bP8V9utRsN8JxJxzUjNSf3k7Uj4BfAFfJpKHQcmFc
   TO0G8qR8P34qrsGXHwSZF8ajrOJP59nSYTRaFm/zucXC950CmwLBMS3+vdU02xGb
   AYZJfFOVtiPU4HdB0Z7KX0aTXbtqRJEEF63tjZcJ7M67zT1xAgMBAAGjdzB1MB0G
   A1UdDgQWBBSSEwsnoHW75GR+74R+9RJDHlMCJTBGBgNVHSMEPzA9gBSSEwsnoHW7
   5GR+74R+9RJDHlMCJaEapBgwFjEUMBIGA1UEAxMLZXhhbXBsZS5jb22CCQD75P7X
   i/gc0TAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBACJdQamPTI/qf6fo
   ovWrffMKnreULYrYAaL4drzQezUpoZ626/Ur3CwpIKqWDsYSvjwKPl0DUyLEuw5J
   2QD4X5n/K7/YGGQJSK8fxazsHavyxQhen1uz7X7zWFflIM6+5DvnOtoq3F0yQ84h
   L6U2LeRpzO4rWw3kxr/jsGkxYaUR
   -----END CERTIFICATE-----
   #+END_HTML

   Here is how we extract private key part of the OpenSSL command:
   #+BEGIN_SRC sh :var pk_and_cert=private_key_and_certificate :results code
   echo "$pk_and_cert" | sed -e 's/^[ ]*//' | head -15
   #+END_SRC

   #+RESULTS:
   #+NAME: private_key_for_testing
   #+BEGIN_SRC sh
   -----BEGIN RSA PRIVATE KEY-----
   MIICXQIBAAKBgQDYrIBJjY822hL90KbvGz/FfbrUbDfCcScc1IzUn95O1I+AXwBX
   yaSh0HJhXEztBvKkfD9+Kq7Blx8EmRfGo6ziT+fZ0mE0WhZv87nFwvedApsCwTEt
   /r3VNNsRmwGGSXxTlbYj1OB3QdGeyl9Gk127akSRBBet7Y2XCezOu809cQIDAQAB
   AoGBALU3MORTfOAHa7LUe4mnZKKsEUHwcIIzWN8H9fEu9CNCK/LVgdfqUcL0L3W2
   WLA1C2L+d6vxzs8isVKLKBN+eOwUnhbMbMtD8h1SbTUV/JFrZsHycNcff4ythjLW
   dMo91+t7EcMKDVmej384Saj8D0z2i1QItvBK/msmSQqdYMXxAkEA72IanU3e5EI1
   rkII0/eVLliK6IM+uhaCgAz7Pt7bxntO2NZ8rscn93v6X7SS2Q/QQKyfsT+AbCXk
   bMCQE/AsFwJBAOe22JWgT1kIlmPVOaid/XErVV9YYdy7SxkAhvQYzHagWfhQaGpX
   sMrX1D5i4eIO9JHRu5zPupCGXRWT43UWr7cCQAi61Smja1t7pqWCNvwz7TbRd89e
   6eyzYXL2BjuWuQEWAhwaRlXBYY2+8bSHy0srLncNVI2MOUy4XQoyQ47WlWUCQGZM
   vZZhrmZ6ehsdWlVtWyWJoil0FdCkB+XD69D82dhNtysAJPk+Odl0LEpW0a9CNwvh
   8tiqhY2lJJeQMU3SdEUCQQCxJ5bXPM5iVDBzV50l3DfDN71srr9KGdCahCuxQpRt
   3ZRkZkz9izeRgRM5GRbOM7xpMWKLXFF0E7Y7jF3aa6xD
   -----END RSA PRIVATE KEY-----
   #+END_SRC

   Here is how we extract the certificate part of the OpenSSL command:
   #+BEGIN_SRC sh :var pk_and_cert=private_key_and_certificate :results code
   echo "$pk_and_cert" | sed -e 's/^[ ]*//' | tail -14
   #+END_SRC

   #+RESULTS:
   #+NAME: certificate_for_testing
   #+BEGIN_SRC sh
   -----BEGIN CERTIFICATE-----
   MIICITCCAYqgAwIBAgIJAPvk/teL+BzRMA0GCSqGSIb3DQEBBQUAMBYxFDASBgNV
   BAMTC2V4YW1wbGUuY29tMB4XDTE2MDIyMzAwNTg1M1oXDTE3MDIyMjAwNTg1M1ow
   FjEUMBIGA1UEAxMLZXhhbXBsZS5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ
   AoGBANisgEmNjzbaEv3Qpu8bP8V9utRsN8JxJxzUjNSf3k7Uj4BfAFfJpKHQcmFc
   TO0G8qR8P34qrsGXHwSZF8ajrOJP59nSYTRaFm/zucXC950CmwLBMS3+vdU02xGb
   AYZJfFOVtiPU4HdB0Z7KX0aTXbtqRJEEF63tjZcJ7M67zT1xAgMBAAGjdzB1MB0G
   A1UdDgQWBBSSEwsnoHW75GR+74R+9RJDHlMCJTBGBgNVHSMEPzA9gBSSEwsnoHW7
   5GR+74R+9RJDHlMCJaEapBgwFjEUMBIGA1UEAxMLZXhhbXBsZS5jb22CCQD75P7X
   i/gc0TAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBACJdQamPTI/qf6fo
   ovWrffMKnreULYrYAaL4drzQezUpoZ626/Ur3CwpIKqWDsYSvjwKPl0DUyLEuw5J
   2QD4X5n/K7/YGGQJSK8fxazsHavyxQhen1uz7X7zWFflIM6+5DvnOtoq3F0yQ84h
   L6U2LeRpzO4rWw3kxr/jsGkxYaUR
   -----END CERTIFICATE-----
   #+END_SRC

   (If you don't need to simulate a JWKs endpoint and you only want to
   validate and sign JWTs, below is how we generate an =RSA PRIVATE
   KEY= to sign JWTs)
   #+BEGIN_SRC sh :results code
     openssl genrsa 1024
   #+END_SRC

   No matter which OpenSSL command you use, this is how to extract the
   =RSA PUBLIC KEY=, which is used to validate JWTs signed with the
   private key.

   Essentially, you =cat= or =echo= the private key into
   =openssl=. However we use the =sed= command below to remove the
   leading whitespace that =org-babel= adds in front of the private key.
   #+BEGIN_SRC sh :var pk_and_cert=private_key_and_certificate :results code
   echo "$pk_and_cert" | sed -e 's/^[ ]*//' | head -15 | openssl rsa -pubout
   #+END_SRC

   #+RESULTS:
   #+NAME: public_key_for_testing
   #+BEGIN_SRC sh
   -----BEGIN PUBLIC KEY-----
   MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDYrIBJjY822hL90KbvGz/FfbrU
   bDfCcScc1IzUn95O1I+AXwBXyaSh0HJhXEztBvKkfD9+Kq7Blx8EmRfGo6ziT+fZ
   0mE0WhZv87nFwvedApsCwTEt/r3VNNsRmwGGSXxTlbYj1OB3QdGeyl9Gk127akSR
   BBet7Y2XCezOu809cQIDAQAB
   -----END PUBLIC KEY-----
   #+END_SRC


   The code for getting the =iat= ("Issued AT") time comes from the
   StackOverflow post: "[[http://stackoverflow.com/a/16755432/3191847][What is the easiest way to get current GMT time
   in Unix timestamp format?]]"

   #+NAME: create_jwt_for_testing
   #+BEGIN_SRC python
     def create_jwt(self, claims={}, kid='TESTKID'):
         d = datetime.utcnow()
         iat = int(calendar.timegm(d.utctimetuple()))
         exp = iat + 3600
         defaults = {
             "sub": "00u0abcdefGHIJKLMNOP",
             "ver": 1,
             "iss": "https://example.okta.com",
             "login": "username@example.com",
             "aud": self.okta['client_id'],
             "iat": iat,
             "exp": exp,
             "amr": [
                 "pwd"
             ],
             "idp": "00o0abcde1FGHIJKLMNO",
             "jti": "abcD0eFgHIJKLmnOPQ1r",
             "auth_time": iat
         }
         for key in claims.keys():
             defaults[key] = claims[key]
         headers = {}
         if kid:
             headers['kid'] = kid
         return jwt.encode(
             defaults,
             private_key,
             algorithm='RS256',
             headers=headers)
   #+END_SRC

   #+BEGIN_SRC python :tangle tests/test_flask_app.py :noweb yes :exports none :padline no
     from datetime import datetime
     import calendar
     import json

     from cryptography.hazmat.backends import default_backend
     from cryptography.hazmat.primitives import serialization
     from nose.tools import raises
     import jwt
     import responses
     import unittest

     import app as flask_app

     certificate = '''
     <<certificate_for_testing>>
     '''

     private_key = '''
     <<private_key_for_testing>>
     '''

     public_key = '''
     <<public_key_for_testing>>
     '''


     class TestFlaskApp(unittest.TestCase):

         def setUp(self):
             self.okta = {
                 'base_url': 'https://example.okta.com',
                 'api_token': '01A2bCd3efGh-ij-4K-Lmn5OPqrSTuvwXYZaBCD6EF',
                 'client_id': 'a0bcdEfGhIJkLmNOPQr1',
                 }
             flask_app.okta = self.okta
             flask_app.app.config['SECRET_KEY'] = "TESTING"
             self.app = flask_app.app.test_client()
             x5c_certificate = ''.join(certificate.split("\n")[2:-2])
             self.oauth2_v1_keys_response = {
                 'keys': [{
                     'kid': 'TESTKID',
                     'x5c': [x5c_certificate, 'FAKE', 'FAKE']
                     }]
                 }
             for domain in ['example.okta.com',
                            'example.oktapreview.com',
                            'invalid.example.com',
                            'invalid.okta.com']:
                 responses.add(
                     responses.GET,
                     'https://{}/.well-known/openid-configuration'.format(domain),
                     json.dumps({
                         'jwks_uri': 'https://{}/oauth2/v1/keys'.format(domain)
                     }),
                     status=200)
                 responses.add(
                     responses.GET,
                     'https://{}/oauth2/v1/keys'.format(domain),
                     json.dumps(self.oauth2_v1_keys_response),
                     status=200)

         def tearDown(self):
             pass

         <<create_jwt_for_testing>>

         <<test_has_default_route>>

         <<test_sso_via_id_token>>

         <<test_parse_jwt_valid>>

         <<test_parse_jwt_invalid_audience>>

         <<test_parse_jwt_invalid_issuer>>

         <<test_fetch_public_key_for_when_empty>>

         <<test_parse_jwt_invalid_kid>>

         <<test_parse_jwt_no_kid>>

         <<test_login_with_password>>
   #+END_SRC
** requirements.txt
   These are the Python packages that this project is built on:

   #+tblname: requirements-table
   |--------------+----------+---------+------------------------------------------------------------------------+-----------------------------------------------|
   | name         | equality | version | description                                                            | url                                           |
   |--------------+----------+---------+------------------------------------------------------------------------+-----------------------------------------------|
   | Flask        | >=       |  0.10.1 | A web framework built with a small core and easy-to-extend philosophy. | http://flask.pocoo.org/                       |
   | Flask-Login  | >=       |   0.3.2 | Provides user session management for Flask.                            | http://flask-login.readthedocs.org/en/latest/ |
   | PyJWT        | >=       |   1.4.0 | JSON Web Token implementation in Python                                | https://github.com/jpadilla/pyjwt             |
   | cryptography |          |         | Exposes cryptographic recipes and primitives.                          | https://cryptography.io/en/latest/            |
   | requests     | ==       |   2.8.1 | HTTP Requests for Humans                                               | http://docs.python-requests.org/en/latest/    |
   | responses    | ==       |   0.5.0 | A utility for mocking out the Requests library.                        | https://github.com/getsentry/responses        |
   | nose         | ==       |   1.3.7 | Extends unittest to make testing easier.                               | https://nose.readthedocs.org/en/latest/       |
   | mock         | ==       |   1.3.0 | mock objects and make assertions about how they have been used.        | https://github.com/testing-cabal/mock         |
   | gunicorn     | >=       |  19.3.0 | WSGI HTTP Server for UNIX.                                             | http://docs.gunicorn.org/en/stable/           |
   |--------------+----------+---------+------------------------------------------------------------------------+-----------------------------------------------|

*** How to turn the table above into a requirements.txt file

    To turn the table above into a =requirements.txt= file, we need to
    do the following:
    1. Convert the table into an array of dictionaries.
    2. Iterate through the array of dictionaries and construct output in
       the =requirements.txt= format, the output must be annotated so
       that it is written to =requirements.txt= when =M-x
       org-bable-tangle= is run on this file.

*** Converting the table to an array of dictionaries
   The code below is taken verbatim from [[http://stackoverflow.com/a/8414248/3191847][a StackOverflow answer]] by [[http://stackoverflow.com/users/174728/john-la-rooy][John
   La Rooy]]. This code takes the table above as an array of arrays and
   returns an array of dictionaries, where the key is the column name
   and the value is the column content. This array of dictionaries is
   used below to generate the =requirements.txt= file.
   #+NAME: table-to-dict
   #+BEGIN_SRC python :var table=requirements-table :results code
     headers = table[0]
     values = table[1:]

     from functools import partial
     from itertools import izip, imap
     data = map(dict, imap(partial(izip, headers), values))

     return data
   #+END_SRC
   #+RESULTS: table-to-dict
   #+BEGIN_SRC python
   [{'url': 'http://flask.pocoo.org/', 'version': '0.10.1', 'equality': '>=', 'name': 'Flask', 'description': 'A web framework built with a small core and easy-to-extend philosophy.'}, {'url': 'http://flask-login.readthedocs.org/en/latest/', 'version': '0.3.2', 'equality': '>=', 'name': 'Flask-Login', 'description': 'Provides user session management for Flask.'}, {'url': 'https://github.com/jpadilla/pyjwt', 'version': '1.4.0', 'equality': '>=', 'name': 'PyJWT', 'description': 'JSON Web Token implementation in Python'}, {'url': 'https://cryptography.io/en/latest/', 'version': '', 'equality': '', 'name': 'cryptography', 'description': 'Exposes cryptographic recipes and primitives.'}, {'url': 'http://docs.python-requests.org/en/latest/', 'version': '2.8.1', 'equality': '==', 'name': 'requests', 'description': 'HTTP Requests for Humans'}, {'url': 'https://github.com/getsentry/responses', 'version': '0.5.0', 'equality': '==', 'name': 'responses', 'description': 'A utility for mocking out the Requests library.'}, {'url': 'https://nose.readthedocs.org/en/latest/', 'version': '1.3.7', 'equality': '==', 'name': 'nose', 'description': 'Extends unittest to make testing easier.'}, {'url': 'https://github.com/testing-cabal/mock', 'version': '1.3.0', 'equality': '==', 'name': 'mock', 'description': 'mock objects and make assertions about how they have been used.'}, {'url': 'http://docs.gunicorn.org/en/stable/', 'version': '19.3.0', 'equality': '>=', 'name': 'gunicorn', 'description': 'WSGI HTTP Server for UNIX.'}]
   #+END_SRC
*** Creating the =requirements.txt= file
   This code takes the requirements table above and turns it into a
   =requirements.txt= file that will get exported when =M-x
   org-bable-tangle= is run.

   #+HEADER: :results_switches ":tangle requirements.txt :noweb yes :exports none :padline no"
   #+BEGIN_SRC python :var table=requirements-table :results code :noweb yes
     data = <<table-to-dict(requirements-table)>>
     output = ''
     for package in data:
	 output += "{name}{equality}{version}\n".format(**package)
     return output
   #+END_SRC

   #+RESULTS:
   #+BEGIN_SRC python :tangle requirements.txt :noweb yes :exports none :padline no
   Flask>=0.10.1
   Flask-Login>=0.3.2
   PyJWT>=1.4.0
   cryptography
   requests==2.8.1
   responses==0.5.0
   nose==1.3.7
   mock==1.3.0
   gunicorn>=19.3.0
   #+END_SRC

** base.html
   TODO:
   - [ ] Explain okta snip too
   - [ ] explain versioning
   - [ ] explain the template tags you can use
   - [ ] Explain the "content" template tag


   The version number for the Okta Sign In Widget is defined below, it
   is used to select the appropriate files to load for the widget. For
   example, if the version of the Okta Sign In Widget is "1.1.0", then
   the filenames used to load the widget will look like this: 
   - =okta-sign-in-1.1.0.min.css=
   - =okta-sign-in-1.1.0.min.js=
   - =okta-theme-1.1.0.css=

   #+NAME: sign-in-widget-version
   #+BEGIN_SRC text :padline no
     1.1.0
   #+END_SRC

   #+NAME: okta-sign-in-widget-includes
   #+BEGIN_SRC html
     <link href="{{okta.base_url}}/js/sdk/okta-sign-in-<<sign-in-widget-version>>.min.css" type="text/css" rel="stylesheet">
     <script src="{{okta.base_url}}/js/sdk/okta-sign-in-<<sign-in-widget-version>>.min.js" type="text/javascript"></script>
   #+END_SRC

   #+NAME: okta-sign-in-widget-theme
   #+BEGIN_SRC html :noweb yes
     <link href="{{okta.base_url}}/js/sdk/okta-theme-<<sign-in-widget-version>>.css" type="text/css" rel="stylesheet">
   #+END_SRC

   #+BEGIN_SRC html :tangle templates/base.html :noweb yes :exports none
     <!DOCTYPE html>
     <html lang="en">
       <head>
	 <meta charset="utf-8">
	 <meta http-equiv="X-UA-Compatible" content="IE=edge">
	 <meta name="viewport" content="width=device-width, initial-scale=1">
	 <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
	 <title>Okta Authentication Example</title>

	 <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
	 
	 <!-- Bootstrap core CSS -->
	 <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-MfvZlkHCEqatNoGiOXveE8FIwMzZg4W85qfrfIFBfYc= sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous">

	 <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
	 <!--[if lt IE 9]>
	   <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
	   <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	   <![endif]-->
	 <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha256-k2/8zcNbxVIh5mnQ52A0r3a6jAgMGxFJFE2707UxGCk= sha512-ZV9KawG2Legkwp3nAlxLIVFudTauWuBpC10uEafMHYL0Sarrz5A7G79kXh5+5+woxQ5HM559XX2UZjMJ36Wplg==" crossorigin="anonymous">
	 <<okta-sign-in-widget-includes>>
	 <link rel="stylesheet" href="https://lipis.github.io/bootstrap-social/bootstrap-social.css">
	 <<okta-sign-in-widget-theme>>
	 <!-- 60px to make the container go all the way to the bottom of the topbar -->
	 <style>
	   body { padding-top: 80px; }
	   #okta-sign-in { margin-top: 0px; }
	 </style>
       </head>
       <body id="main">
	 <nav class="navbar navbar-inverse navbar-fixed-top">
	   <div class="container">
	     <div class="navbar-header">
	       <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
		 <span class="sr-only">Toggle navigation</span>
		 <span class="icon-bar"></span>
		 <span class="icon-bar"></span>
		 <span class="icon-bar"></span>
	       </button>
	       <a class="navbar-brand" href="#">Okta Authentication Example</a>
	     </div>
	     <div id="navbar" class="collapse navbar-collapse">
	       <ul class="nav navbar-nav">
		 {% if 'user' in opts and opts['user'].is_authenticated() %}
		 <li><a href="/logout">Log out</a></li>
		 {% endif %}
	       </ul>
	     </div><!--/.nav-collapse -->
	   </div>
	 </nav>
	 <div class="container">
	   {% block body %}
	   {% endblock %}
	 </div><!-- /.container -->
	 {% block javascript %}
	 {% endblock %}
	 <!-- Placed at the end of the document so the pages load faster -->
	 <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js" integrity="sha256-Sk3nkD6mLTMOF0EOpNtsIry+s1CsaqQC1rVLTAy+0yc= sha512-K1qjQ+NcF2TYO/eI3M6v8EiNYZfA95pQumfvcVrTHtwQVDG+aHRqLi/ETn2uB+1JqwYqVG3LIvdm9lj6imS/pQ==" crossorigin="anonymous"></script>
       </body>
     </html>

   #+END_SRC
** main_page.html
   #+NAME: configure-okta-sign-in-success-handler
   #+BEGIN_SRC javascript
     oktaSignIn.renderEl(
       { el: '#okta-sign-in-widget' },
      function (res) {
         console.log(res);
         var id_token = res.id_token || res.idToken;
         if (res.status === 'SUCCESS') {
           $.post("/sso/oidc", {"id_token": id_token}, function(data) {
             window.location.href="/secret";
           });
         }
       },
      function (err) { console.log('Unexpected error authenticating user: %o', err); }
     );
   #+END_SRC

   #+BEGIN_SRC html :tangle templates/main_page.html :noweb yes :exports none
     {% extends "base.html" %}
     {% block body %}
           <div class="row">
             <div class="col-md-6">
               <p>
               This is a demonstration of how to use Okta to handle authentication for a server side application.
               </p>
               <!-- Source: http://openclipart.org/detail/34273/tango-system-lock-screen-by-warszawianka -->
               <img src="/static/locked-screen.png" alt="Locked computer screen"/>
             </div>
             <div class="col-md-6">
               <p class="text-center">
                 Enter your credentials below to log in <button type="button" id="login-toggle" class="btn btn-default btn-sm">without</button> the Okta Sign In Widget:
               </p>
               <br/>
               <div id="okta-sign-in-widget"></div>
               <<form-login-template>>
             </div>
           </div>
     {% endblock %}
     {% block javascript %}
           <script>
             <<login-form-toggle>>
             <<setup-okta-sign-in>>
             var oktaSignIn = setupOktaSignIn('{{okta.base_url}}', '{{okta.client_id}}');
             <<configure-okta-sign-in-success-handler>>
           </script>
     {% endblock %}      
   #+END_SRC
   #+NAME: form-login-template
   #+BEGIN_SRC html 
     <div id="okta-login" style="display: block;">
       <div class="auth-container main-container no-beacon" id="okta-sign-in">
         <div class="auth-content">
           <div class="auth-content-inner">
             <div class="primary-auth">
               <form action="/login" class="primary-auth-form o-form o-form-edit-mode" method="post">
                 <div class="o-form-content o-form-theme clearfix">
                   <h2 class="okta-form-title o-form-head">Sign In</h2>
                   <div class="o-form-error-container"></div>
                   <div class="o-form-fieldset-container">
                     <div class="o-form-fieldset o-form-label-top">
                       <div class="o-form-input">
                        <span class="okta-form-input-field input-fix o-form-control">
                         <span class="icon input-icon person-16-gray"></span>
                         <input autocomplete="off" id="inputUsername" name="username" placeholder="Username" type="text" value="">
                       </span>
                       </div>
                     </div>
                     <div class="o-form-fieldset o-form-label-top">
                       <div class="o-form-input">
                         <span class="okta-form-input-field input-fix o-form-control">
                           <span class="icon input-icon remote-lock-16"></span>
                           <input autocomplete="off" id="inputPassword" name="password" placeholder="Password" type="password" value=""></span>
                       </div>
                     </div>
                   </div>
                 </div>
                 {% with messages = get_flashed_messages() %}
                 {% if messages %}
                 {% for error in messages %}
                 <div class="alert alert-danger">
                   <span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span>
                   <span class="sr-only">Error:</span> {{ error }}
                 </div>
                 {% endfor %}
                 {% endif %}
                 {% endwith %}
                 <div class="o-form-button-bar">
                   <input class="button button-primary" data-type="save" type="submit" value="Sign In">
                 </div>
               </form>
               <div class="auth-footer">
                 <a href="{{login_with_okta_branding}}">Login using Okta branded page</a>
               </div>
             </div>
           </div>
         </div>
       </div>
     </div>
   #+END_SRC
   #+NAME: login-form-toggle
   #+BEGIN_SRC javascript
     $("#okta-sign-in-widget").hide();
     $("#login-toggle").click(function () {
	 $("#okta-sign-in-widget").toggle();
	 $("#okta-login").toggle();
	 var text = $("#login-toggle").text();
	 $("#login-toggle").html(
	     text == "without" ? "with" : "without"
	 );
     });
   #+END_SRC
** secret.html
** LICENSE.txt
   #+BEGIN_SRC text :tangle LICENSE.txt
     Copyright Â© 2015-2016, Okta, Inc.

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

	 http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
   #+END_SRC
** Procfile
   This file should use gunicorn, but that was causing unexpected 500
   errors on Heroku. So I'm using =python app.py= instead.
   #+BEGIN_EXAMPLE
     web: gunicorn app:app --log-file=-
   #+END_EXAMPLE

   #+BEGIN_SRC text :tangle Procfile :padline no
     web: python app.py
   #+END_SRC
* Testing 							   :noexport:
  #+BEGIN_SRC sh
    nosetests tests/
  #+END_SRC

  #+RESULTS:
* To do								   :noexport:
** DONE Add support for widgetless login 
   This would use the =/authn= endpoint, then redirect
** DONE Implement SAML ACS-like route to handle =id_token= and 302
** TODO Add documentation on support for "IDP initiated" flows
   ... where the user redirect flow starts at Okta
** TODO Add support for =/sessions/me= to the SPA example
** TODO Add more strict JWT checks
   http://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-08#section-3
* Learn more

  Want to learn more about Open ID Connect and OAuth?

  Here is what we suggest that you read to learn more:
  - Aaron Parecki's "[[https://aaronparecki.com/articles/2012/07/29/1/oauth2-simplified][OAuth 2 Simplified]]" post.

    Start here if you don't know anything about OAuth 2.
  - Karl McGuinness' "[[http://developer.okta.com/blog/2015/12/07/oauth/][Demystifying OAuth]]" video and slides.
    
    This is a great high level guide that covers the basics of OAuth.
  - [[http://openid.net/specs/openid-connect-implicit-1_0.html][OpenID Connect Implicit Client Implementer's Guide]]

    An official guide for implementing the "implicit" flow. Language
    agnostic and very useful for learning the details on how things
    work.

* Footnotes							   :noexport:

[fn:1] Description from: http://www.fullstackpython.com/flask.html

